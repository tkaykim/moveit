# 비회원 계좌이체 예약 — 구현 개선사항 및 설계 노트

이 문서는 `비회원_계좌이체_예약_및_회원가입_매핑.md`의 계획을 실제 구현한 뒤, 코드 검토 과정에서 발견된 버그·엣지 케이스·설계 결정을 정리한 것입니다.

---

## 1. 수정된 버그

### 1.1 ordererName / depositorName 혼동 (프론트)

**파일**: `app/(main)/book/session/[sessionId]/page.tsx`

**문제**
비회원 신청 시 `submitBankTransferOrder(depositorName, phone, email)` 형태로 호출했기 때문에, API의 `ordererName` 파라미터에 입금자명(depositorName)이 들어갔다. 실제 주문자 이름(guestOrderer.name)이 DB에 저장되지 않았음.

**수정**
```
비회원: submitBankTransferOrder(guestOrderer.name, phone, email, depositorName)
회원:   submitBankTransferOrder(depositorName)   ← 기존 동작 유지
```
- `ordererName` 파라미터 → 실제 주문자 이름 (guestOrderer.name)
- `depositorNameArg` 파라미터(신규) → 입금 시 쓸 이름 (depositorName 입력값)
- API body에 `depositorName` 필드 추가 전달

**결과**
- DB `bank_transfer_orders.orderer_name` = 실제 주문자 이름 ✅
- `depositorName` = 입금자명 (별도 처리)

---

### 1.2 입금자명 화면 표시 오류

**파일**: `app/(main)/book/session/[sessionId]/page.tsx`, `app/api/tickets/bank-transfer-order/route.ts`

**문제**
1.1 수정 이후, API response에 `depositorName`이 없었기 때문에 계좌 안내 화면의 "입금자명" 항목이 `ordererName`(주문자명)을 표시하게 됨. 두 값이 다른 경우(드물지만 가능) 고객이 잘못된 이름으로 입금할 수 있었음.

**수정**
- API response에 `depositorName` 추가 반환
- `bankTransferResult` 타입에 `depositorName?: string` 추가
- 화면 표시: `depositorName || ordererName` 순서로 렌더링

**결과**
- 고객 화면 "입금자명" = 실제 입금 시 쓸 이름 ✅

---

### 1.3 완료 모달에서 탈출 불가 (비회원)

**파일**: `app/(main)/book/session/[sessionId]/page.tsx`

**문제**
비회원 계좌이체 완료 후 성공 모달에 "회원가입"과 "로그인" 버튼만 있었고, 닫을 방법이 없었음. 회원가입/로그인을 원하지 않는 비회원은 모달에 갇히는 UX 문제.

**수정**
"나중에 하기" 버튼 추가. 클릭 시 `showBankTransferSuccessThenRedirect = false`, `bankTransferCompletedAsGuest = false` 로 상태만 초기화하고 종료. `bankTransferAuthRedirectRef`는 건드리지 않음 (이미 false 상태).

---

## 2. 신규 구현

### 2.1 bankTransferCompletedAsGuest 상태

비회원 신청 성공 직전 `isGuest = !!guestOrderer` 를 캡처하여 상태로 보관. 성공 모달에서 회원/비회원 UI 분기에 사용.

- 비회원: "예약 현황을 확인하려면 회원가입 또는 로그인해 주세요." + 회원가입/로그인/나중에 하기
- 회원: "마이페이지로 이동"

### 2.2 bankTransferAuthRedirectRef

성공 모달의 "회원가입" 또는 "로그인" 버튼 클릭 시 `bankTransferAuthRedirectRef.current = true` 설정. MyTab `onClose` 시 이 값이 true이면 로그인 여부를 확인하여 로그인 성공 시 `/my` 로 이동.

**onClose 로직**
```
if (bankTransferAuthRedirectRef.current) {
  ref = false
  getUser() → 로그인됨 → router.push('/my')  ← checkAuth() 호출 안 함
                로그인 안됨 → checkAuth() 호출 (일반 흐름 유지)
}
```

**ref 격리**: ref는 성공 모달 버튼에서만 true로 설정됨. 다른 경로(수강권 선택 로그인 유도, bankTransferAuthModal 등)에서 isAuthModalOpen이 열려도 ref = false 이므로 /my 이동 없음.

### 2.3 POST /api/me/link-guest-bookings

**파일**: `app/api/me/link-guest-bookings/route.ts`

로그인된 사용자의 phone을 기준으로 비회원 시절 예약을 매핑.

```
bookings: user_id IS NULL AND guest_phone = user.phone → user_id = user.id
bank_transfer_orders: user_id IS NULL AND orderer_phone = user.phone → user_id = user.id (선택적)
```

- 인증 없으면 401 반환
- phone 없으면 linked: 0 반환 (오류 아님)
- 중복 호출 safe: 이미 매핑된 행은 `user_id IS NULL` 조건 불일치로 skip
- bank_transfer_orders 매핑 실패는 무시하고 진행 (예약 매핑이 핵심)

**admin 확인 시 순서 의존성**

| 순서 | 결과 |
|------|------|
| link → admin 확인 | order.user_id 있음 → 수강권 발급 + 예약 확정 ✅ |
| admin 확인 → link | order.user_id = null → 수강권 미발급, 예약만 CONFIRMED. link 후에도 수강권 없음 ⚠️ |

두 번째 경우는 기존 스펙 동작("주문자 연락처로 수강권 수령 방법 안내").

### 2.4 /my 진입 시 link-guest-bookings 1회 호출

**파일**: `components/views/my-page-view.tsx`

```ts
const linkGuestDoneRef = useRef(false);
useEffect(() => {
  if (!user || authLoading || linkGuestDoneRef.current) return;
  linkGuestDoneRef.current = true;
  fetchWithAuth('/api/me/link-guest-bookings', { method: 'POST' }).catch(() => {});
}, [user, authLoading]);
```

- useRef로 컴포넌트 생존 중 중복 호출 방지
- 언마운트 후 재마운트 시 ref 초기화 → 재호출되지만 API가 idempotent라 무해
- 오류는 조용히 무시 (매핑 실패가 예약 화면을 막아서는 안 됨)

---

## 3. 시나리오별 검증

### 시나리오 1: 비회원 예약 후 아무것도 안 함

```
비회원 폼 → 입금자명 → 신청
  → API: user_id=null, orderer_name=주문자명, guest_name=주문자명, guest_phone=연락처
  → 계좌 안내 → "확인"
  → 성공 모달: 회원가입 / 로그인 / 나중에 하기
  → "나중에 하기" → 모달 닫힘. 끝.
admin: 비회원 뱃지, 입금 확인 시 booking CONFIRMED (수강권 미발급)
```

### 시나리오 2: 비회원 예약 → 회원가입

```
  → 성공 모달 "회원가입" → ref = true → MyTab(signup) 열림
  → 회원가입 완료 → onClose
    → ref = true → getUser() → 로그인됨 → router.push('/my')
  → /my 마운트 → link-guest-bookings 호출
    → guest_phone 일치 booking에 user_id 설정
  → /my에서 예약 내역 확인 가능
```

### 시나리오 3: 기존 계정 유저가 비회원으로 예약 → 로그인

```
  → 성공 모달 "로그인" → ref = true → MyTab(login)
  → 로그인 완료 → onClose → router.push('/my')
  → /my → link-guest-bookings → booking 매핑 → 예약 내역 확인 가능
```

### 시나리오 3 변형: 회원가입/로그인 도중 취소

```
  → 성공 모달 "회원가입" → ref = true → MyTab 열림
  → 사용자 취소 → onClose
    → ref = true → getUser() → 로그인 안됨
    → ref = false → checkAuth() 실행 (일반 흐름)
  → 예약 페이지 그대로. 아무 이동 없음. ✅
```

### 시나리오 4: 로그인된 회원

```
  → bankTransferAuthModal 건너뜀
  → 직접 depositor 모달 (프로필 이름 자동 입력)
  → 신청: user_id = user.id
  → bankTransferCompletedAsGuest = false
  → 성공 모달: "마이페이지로 이동" 버튼만 표시 → /my
```

---

## 4. 설계 결정 및 엣지 케이스

### 4.1 checkAuth() 미호출 시 user 상태 업데이트

`bankTransferAuthRedirectRef`가 true이고 로그인 성공이면 `router.push('/my')` 후 즉시 return하여 `checkAuth()`를 호출하지 않음. 의도된 동작. `/my`로 이동하면 해당 페이지에서 auth 상태를 독립적으로 확인하므로 현재 예약 페이지의 user 상태를 갱신할 필요가 없음.

### 4.2 "나중에 하기" 클릭 시 ref 처리

"나중에 하기"는 `showBankTransferSuccessThenRedirect = false`와 `bankTransferCompletedAsGuest = false`만 초기화. `bankTransferAuthRedirectRef`는 이 시점에 이미 false이므로 건드리지 않음. 이후 isAuthModalOpen이 다른 경로로 열려도 ref가 false라 /my 이동 없음.

### 4.3 MyTab onClose 시 checkAuth 호출 생략

/my 리다이렉트 경로에서는 checkAuth()를 호출하지 않음. /my 페이지가 자체적으로 auth 상태를 처리하므로 예약 페이지의 user 상태 갱신이 불필요하기 때문.

### 4.4 회원가입 직후 세션 반영 지연

이메일 인증 대기 등 세션 반영이 즉시 이루어지지 않는 플로우에서는, MyTab onClose 시점의 `getUser()`가 null을 반환할 수 있음. 이 경우 `/my` 자동 이동이 한 번 누락될 수 있음.

**대응**: 일반적인 즉시 로그인(소셜 로그인, 이메일+비밀번호 로그인)에서는 문제 없음. 이메일 인증 대기가 있는 가입 플로우라면 onClose 시점에 세션이 없으므로 checkAuth()만 실행되고 /my 이동은 없음. 이 경우 사용자가 수동으로 /my에 접근하면 link-guest-bookings가 정상 실행됨.

---

## 5. 남아있는 한계 → 적용 완료 (2025-02-28)

| 항목 | 설명 | 적용 내용 |
|------|------|-----------|
| 전화번호 포맷 불일치 | "010-1234-5678" vs "01012345678" 형태가 다르면 link 불일치 | **적용**: link-guest-bookings에서 숫자만 추출해 비교 (normalizePhone) |
| 이메일 전용 비회원 예약 | `guest_phone`이 없으면 link-guest-bookings가 매핑하지 못함 | **적용**: `bookings.guest_email` 마이그레이션 추가, 이메일 기준 매칭 추가 |
| admin 입금자명 컬럼 | depositorName이 다른 경우 관리자 검색/표시 불일치 | **적용**: `bank_transfer_orders.depositor_name` 마이그레이션, API·목록 검색·표시 반영 |
| /my 첫 로드 레이스 | link와 loadData 병렬 호출로 연동 직후 목록에 안 뜸 | **적용**: my-page-view에서 link-guest-bookings 먼저 await 후 loadData 호출 |

**아직 설계 범위 밖 (변경 없음)**

| 항목 | 설명 |
|------|------|
| admin 확인 후 link | admin이 먼저 입금 확인하면 비회원 처리 → 수강권 미발급. 이후 회원가입해도 수강권 없음. 학원 수동 안내로 대응. |
| /my 이외 경로에서 link 미실행 | `/my/bookings` 등 직접 접근 시 link-guest-bookings 미호출. 필요 시 AuthContext 레벨로 이동 가능. |

**배포 순서**: DB 마이그레이션(`supabase/migrations/20250228100000_bookings_guest_email.sql`, `20250228110000_bank_transfer_orders_depositor_name.sql`)을 먼저 적용한 뒤 코드 배포.

---

## 6. 수정·추가 파일 최종 요약

| 파일 | 변경 유형 | 내용 |
|------|-----------|------|
| `app/(main)/book/session/[sessionId]/page.tsx` | 수정 | ordererName/depositorName 분리, bankTransferCompletedAsGuest, bankTransferAuthRedirectRef, "나중에 하기" 버튼, MyTab onClose /my 이동, depositorName 타입·표시 |
| `app/api/tickets/bank-transfer-order/route.ts` | 수정 | response에 depositorName 추가 반환, depositor_name 저장, guest 시 guest_email 저장 |
| `app/api/me/link-guest-bookings/route.ts` | 수정 | 전화번호 정규화 비교, 이메일(guest_email/orderer_email) 기준 매칭 추가 |
| `components/views/my-page-view.tsx` | 수정 | /my 진입 시 link-guest-bookings 먼저 await 후 loadData 호출 (레이스 제거) |
| `app/api/academy-admin/[academyId]/bank-transfer-orders/route.ts` | 수정 | depositor_name 조회·검색(q) 포함 |
| `app/academy-admin/.../deposit-confirm-view.tsx` | 수정 | depositor_name 타입·표시(주문자명 / 입금: 입금자명) |
| `supabase/migrations/20250228100000_bookings_guest_email.sql` | 신규 | bookings.guest_email 컬럼 추가 |
| `supabase/migrations/20250228110000_bank_transfer_orders_depositor_name.sql` | 신규 | bank_transfer_orders.depositor_name 컬럼 추가 |
